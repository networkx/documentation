
<!DOCTYPE html>


<html lang="en" data-content_root="../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>networkx.algorithms.d_separation &#8212; NetworkX 3.4.2 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=f84a2825" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../_static/documentation_options.js?v=c65d4aa2"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/copybutton.js?v=e333d19b"></script>
    <script data-domain="networkx.org" defer="defer" src="https://views.scientific-python.org/js/script.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/networkx/algorithms/d_separation';</script>
    <script>
        DOCUMENTATION_OPTIONS.theme_version = '0.15.4';
        DOCUMENTATION_OPTIONS.theme_switcher_json_url = 'https://networkx.org/documentation/latest/_static/version_switcher.json';
        DOCUMENTATION_OPTIONS.theme_switcher_version_match = '3.4.2';
        DOCUMENTATION_OPTIONS.show_version_warning_banner = true;
        </script>
    <link rel="canonical" href="https://networkx.org/documentation/stable/_modules/networkx/algorithms/d_separation.html" />
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within NetworkX 3.4.2 documentation"
          href="../../../_static/opensearch.xml"/>
    <link rel="icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
    <meta name="docbuild:last-update" content="Oct 21, 2024"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../_static/networkx_banner.svg" class="logo__image only-light" alt="NetworkX 3.4.2 documentation - Home"/>
    <script>document.write(`<img src="../../../_static/networkx_banner.svg" class="logo__image only-dark" alt="NetworkX 3.4.2 documentation - Home"/>`);</script>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../tutorial.html">
    Tutorial
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../backends.html">
    Backends
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../developer/index.html">
    Developer
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../release/index.html">
    Releases
  </a>
</li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">
                    
<li class=" ">
  <a class="nav-link dropdown-item nav-external" href="https://networkx.org/nx-guides/">
    Guides
  </a>
</li>

                </ul>
            </li>
            
  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>
      
      
        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://networkx.org" title="Home Page" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-home fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Home Page</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/networkx/networkx" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github-square fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
        <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-2"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-2"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-2"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-2">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../install.html">
    Install
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../tutorial.html">
    Tutorial
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../backends.html">
    Backends
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../reference/index.html">
    Reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../auto_examples/index.html">
    Gallery
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../developer/index.html">
    Developer
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../release/index.html">
    Releases
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-external" href="https://networkx.org/nx-guides/">
    Guides
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://networkx.org" title="Home Page" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-home fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Home Page</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/networkx/networkx" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fab fa-github-square fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
          <div class="navbar-item">
<script>
document.write(`
  <div class="version-switcher__container dropdown">
    <button id="pst-version-switcher-button-3"
      type="button"
      class="version-switcher__button btn btn-sm dropdown-toggle"
      data-bs-toggle="dropdown"
      aria-haspopup="listbox"
      aria-controls="pst-version-switcher-list-3"
      aria-label="Version switcher list"
    >
      Choose version  <!-- this text may get changed later by javascript -->
      <span class="caret"></span>
    </button>
    <div id="pst-version-switcher-list-3"
      class="version-switcher__menu dropdown-menu list-group-flush py-0"
      role="listbox" aria-labelledby="pst-version-switcher-button-3">
      <!-- dropdown will be populated by javascript on page load -->
    </div>
  </div>
`);
</script></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">



<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page">networkx.alg...</li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for networkx.algorithms.d_separation</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Algorithm for testing d-separation in DAGs.</span>

<span class="sd">*d-separation* is a test for conditional independence in probability</span>
<span class="sd">distributions that can be factorized using DAGs.  It is a purely</span>
<span class="sd">graphical test that uses the underlying graph and makes no reference</span>
<span class="sd">to the actual distribution parameters.  See [1]_ for a formal</span>
<span class="sd">definition.</span>

<span class="sd">The implementation is based on the conceptually simple linear time</span>
<span class="sd">algorithm presented in [2]_.  Refer to [3]_, [4]_ for a couple of</span>
<span class="sd">alternative algorithms.</span>

<span class="sd">The functional interface in NetworkX consists of three functions:</span>

<span class="sd">- `find_minimal_d_separator` returns a minimal d-separator set ``z``.</span>
<span class="sd">  That is, removing any node or nodes from it makes it no longer a d-separator.</span>
<span class="sd">- `is_d_separator` checks if a given set is a d-separator.</span>
<span class="sd">- `is_minimal_d_separator` checks if a given set is a minimal d-separator.</span>

<span class="sd">D-separators</span>
<span class="sd">------------</span>

<span class="sd">Here, we provide a brief overview of d-separation and related concepts that</span>
<span class="sd">are relevant for understanding it:</span>

<span class="sd">The ideas of d-separation and d-connection relate to paths being open or blocked.</span>

<span class="sd">- A &quot;path&quot; is a sequence of nodes connected in order by edges. Unlike for most</span>
<span class="sd">  graph theory analysis, the direction of the edges is ignored. Thus the path</span>
<span class="sd">  can be thought of as a traditional path on the undirected version of the graph.</span>
<span class="sd">- A &quot;candidate d-separator&quot; ``z`` is a set of nodes being considered as</span>
<span class="sd">  possibly blocking all paths between two prescribed sets ``x`` and ``y`` of nodes.</span>
<span class="sd">  We refer to each node in the candidate d-separator as &quot;known&quot;.</span>
<span class="sd">- A &quot;collider&quot; node on a path is a node that is a successor of its two neighbor</span>
<span class="sd">  nodes on the path. That is, ``c`` is a collider if the edge directions</span>
<span class="sd">  along the path look like ``... u -&gt; c &lt;- v ...``.</span>
<span class="sd">- If a collider node or any of its descendants are &quot;known&quot;, the collider</span>
<span class="sd">  is called an &quot;open collider&quot;. Otherwise it is a &quot;blocking collider&quot;.</span>
<span class="sd">- Any path can be &quot;blocked&quot; in two ways. If the path contains a &quot;known&quot; node</span>
<span class="sd">  that is not a collider, the path is blocked. Also, if the path contains a</span>
<span class="sd">  collider that is not a &quot;known&quot; node, the path is blocked.</span>
<span class="sd">- A path is &quot;open&quot; if it is not blocked. That is, it is open if every node is</span>
<span class="sd">  either an open collider or not a &quot;known&quot;. Said another way, every</span>
<span class="sd">  &quot;known&quot; in the path is a collider and every collider is open (has a</span>
<span class="sd">  &quot;known&quot; as a inclusive descendant). The concept of &quot;open path&quot; is meant to</span>
<span class="sd">  demonstrate a probabilistic conditional dependence between two nodes given</span>
<span class="sd">  prescribed knowledge (&quot;known&quot; nodes).</span>
<span class="sd">- Two sets ``x`` and ``y`` of nodes are &quot;d-separated&quot; by a set of nodes ``z``</span>
<span class="sd">  if all paths between nodes in ``x`` and nodes in ``y`` are blocked. That is,</span>
<span class="sd">  if there are no open paths from any node in ``x`` to any node in ``y``.</span>
<span class="sd">  Such a set ``z`` is a &quot;d-separator&quot; of ``x`` and ``y``.</span>
<span class="sd">- A &quot;minimal d-separator&quot; is a d-separator ``z`` for which no node or subset</span>
<span class="sd">  of nodes can be removed with it still being a d-separator.</span>

<span class="sd">The d-separator blocks some paths between ``x`` and ``y`` but opens others.</span>
<span class="sd">Nodes in the d-separator block paths if the nodes are not colliders.</span>
<span class="sd">But if a collider or its descendant nodes are in the d-separation set, the</span>
<span class="sd">colliders are open, allowing a path through that collider.</span>

<span class="sd">Illustration of D-separation with examples</span>
<span class="sd">------------------------------------------</span>

<span class="sd">A pair of two nodes, ``u`` and ``v``, are d-connected if there is a path</span>
<span class="sd">from ``u`` to ``v`` that is not blocked. That means, there is an open</span>
<span class="sd">path from ``u`` to ``v``.</span>

<span class="sd">For example, if the d-separating set is the empty set, then the following paths are</span>
<span class="sd">open between ``u`` and ``v``:</span>

<span class="sd">- u &lt;- n -&gt; v</span>
<span class="sd">- u -&gt; w -&gt; ... -&gt; n -&gt; v</span>

<span class="sd">If  on the other hand, ``n`` is in the d-separating set, then ``n`` blocks</span>
<span class="sd">those paths between ``u`` and ``v``.</span>

<span class="sd">Colliders block a path if they and their descendants are not included</span>
<span class="sd">in the d-separating set. An example of a path that is blocked when the</span>
<span class="sd">d-separating set is empty is:</span>

<span class="sd">- u -&gt; w -&gt; ... -&gt; n &lt;- v</span>

<span class="sd">The node ``n`` is a collider in this path and is not in the d-separating set.</span>
<span class="sd">So ``n`` blocks this path. However, if ``n`` or a descendant of ``n`` is</span>
<span class="sd">included in the d-separating set, then the path through the collider</span>
<span class="sd">at ``n`` (... -&gt; n &lt;- ...) is &quot;open&quot;.</span>

<span class="sd">D-separation is concerned with blocking all paths between nodes from ``x`` to ``y``.</span>
<span class="sd">A d-separating set between ``x`` and ``y`` is one where all paths are blocked.</span>

<span class="sd">D-separation and its applications in probability</span>
<span class="sd">------------------------------------------------</span>

<span class="sd">D-separation is commonly used in probabilistic causal-graph models. D-separation</span>
<span class="sd">connects the idea of probabilistic &quot;dependence&quot; with separation in a graph. If</span>
<span class="sd">one assumes the causal Markov condition [5]_, (every node is conditionally</span>
<span class="sd">independent of its non-descendants, given its parents) then d-separation implies</span>
<span class="sd">conditional independence in probability distributions.</span>
<span class="sd">Symmetrically, d-connection implies dependence.</span>

<span class="sd">The intuition is as follows. The edges on a causal graph indicate which nodes</span>
<span class="sd">influence the outcome of other nodes directly. An edge from u to v</span>
<span class="sd">implies that the outcome of event ``u`` influences the probabilities for</span>
<span class="sd">the outcome of event ``v``. Certainly knowing ``u`` changes predictions for ``v``.</span>
<span class="sd">But also knowing ``v`` changes predictions for ``u``. The outcomes are dependent.</span>
<span class="sd">Furthermore, an edge from ``v`` to ``w`` would mean that ``w`` and ``v`` are dependent</span>
<span class="sd">and thus that ``u`` could indirectly influence ``w``.</span>

<span class="sd">Without any knowledge about the system (candidate d-separating set is empty)</span>
<span class="sd">a causal graph ``u -&gt; v -&gt; w`` allows all three nodes to be dependent. But</span>
<span class="sd">if we know the outcome of ``v``, the conditional probabilities of outcomes for</span>
<span class="sd">``u`` and ``w`` are independent of each other. That is, once we know the outcome</span>
<span class="sd">for ```v`, the probabilities for ``w`` do not depend on the outcome for ``u``.</span>
<span class="sd">This is the idea behind ``v`` blocking the path if it is &quot;known&quot; (in the candidate</span>
<span class="sd">d-separating set).</span>

<span class="sd">The same argument works whether the direction of the edges are both</span>
<span class="sd">left-going and when both arrows head out from the middle. Having a &quot;known&quot;</span>
<span class="sd">node on a path blocks the collider-free path because those relationships</span>
<span class="sd">make the conditional probabilities independent.</span>

<span class="sd">The direction of the causal edges does impact dependence precisely in the</span>
<span class="sd">case of a collider e.g. ``u -&gt; v &lt;- w``. In that situation, both ``u`` and ``w``</span>
<span class="sd">influence ``v```. But they do not directly influence each other. So without any</span>
<span class="sd">knowledge of any outcomes, ``u`` and ``w`` are independent. That is the idea behind</span>
<span class="sd">colliders blocking the path. But, if ``v`` is known, the conditional probabilities</span>
<span class="sd">of ``u`` and ``w`` can be dependent. This is the heart of Berkson&#39;s Paradox [6]_.</span>
<span class="sd">For example, suppose ``u`` and ``w`` are boolean events (they either happen or do not)</span>
<span class="sd">and ``v`` represents the outcome &quot;at least one of ``u`` and ``w`` occur&quot;. Then knowing</span>
<span class="sd">``v`` is true makes the conditional probabilities of ``u`` and ``w`` dependent.</span>
<span class="sd">Essentially, knowing that at least one of them is true raises the probability of</span>
<span class="sd">each. But further knowledge that ``w`` is true (or false) change the conditional</span>
<span class="sd">probability of ``u`` to either the original value or 1. So the conditional</span>
<span class="sd">probability of ``u`` depends on the outcome of ``w`` even though there is no</span>
<span class="sd">causal relationship between them. When a collider is known, dependence can</span>
<span class="sd">occur across paths through that collider. This is the reason open colliders</span>
<span class="sd">do not block paths.</span>

<span class="sd">Furthermore, even if ``v`` is not &quot;known&quot;, if one of its descendants is &quot;known&quot;</span>
<span class="sd">we can use that information to know more about ``v`` which again makes</span>
<span class="sd">``u`` and ``w`` potentially dependent. Suppose the chance of ``n`` occurring</span>
<span class="sd">is much higher when ``v`` occurs (&quot;at least one of ``u`` and ``w`` occur&quot;).</span>
<span class="sd">Then if we know ``n`` occurred, it is more likely that ``v`` occurred and that</span>
<span class="sd">makes the chance of ``u`` and ``w`` dependent. This is the idea behind why</span>
<span class="sd">a collider does no block a path if any descendant of the collider is &quot;known&quot;.</span>

<span class="sd">When two sets of nodes ``x`` and ``y`` are d-separated by a set ``z``,</span>
<span class="sd">it means that given the outcomes of the nodes in ``z``, the probabilities</span>
<span class="sd">of outcomes of the nodes in ``x`` are independent of the outcomes of the</span>
<span class="sd">nodes in ``y`` and vice versa.</span>

<span class="sd">Examples</span>
<span class="sd">--------</span>
<span class="sd">A Hidden Markov Model with 5 observed states and 5 hidden states</span>
<span class="sd">where the hidden states have causal relationships resulting in</span>
<span class="sd">a path results in the following causal network. We check that</span>
<span class="sd">early states along the path are separated from late state in</span>
<span class="sd">the path by the d-separator of the middle hidden state.</span>
<span class="sd">Thus if we condition on the middle hidden state, the early</span>
<span class="sd">state probabilities are independent of the late state outcomes.</span>

<span class="sd">&gt;&gt;&gt; G = nx.DiGraph()</span>
<span class="sd">&gt;&gt;&gt; G.add_edges_from(</span>
<span class="sd">...     [</span>
<span class="sd">...         (&quot;H1&quot;, &quot;H2&quot;),</span>
<span class="sd">...         (&quot;H2&quot;, &quot;H3&quot;),</span>
<span class="sd">...         (&quot;H3&quot;, &quot;H4&quot;),</span>
<span class="sd">...         (&quot;H4&quot;, &quot;H5&quot;),</span>
<span class="sd">...         (&quot;H1&quot;, &quot;O1&quot;),</span>
<span class="sd">...         (&quot;H2&quot;, &quot;O2&quot;),</span>
<span class="sd">...         (&quot;H3&quot;, &quot;O3&quot;),</span>
<span class="sd">...         (&quot;H4&quot;, &quot;O4&quot;),</span>
<span class="sd">...         (&quot;H5&quot;, &quot;O5&quot;),</span>
<span class="sd">...     ]</span>
<span class="sd">... )</span>
<span class="sd">&gt;&gt;&gt; x, y, z = ({&quot;H1&quot;, &quot;O1&quot;}, {&quot;H5&quot;, &quot;O5&quot;}, {&quot;H3&quot;})</span>
<span class="sd">&gt;&gt;&gt; nx.is_d_separator(G, x, y, z)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; nx.is_minimal_d_separator(G, x, y, z)</span>
<span class="sd">True</span>
<span class="sd">&gt;&gt;&gt; nx.is_minimal_d_separator(G, x, y, z | {&quot;O3&quot;})</span>
<span class="sd">False</span>
<span class="sd">&gt;&gt;&gt; z = nx.find_minimal_d_separator(G, x | y, {&quot;O2&quot;, &quot;O3&quot;, &quot;O4&quot;})</span>
<span class="sd">&gt;&gt;&gt; z == {&quot;H2&quot;, &quot;H4&quot;}</span>
<span class="sd">True</span>

<span class="sd">If no minimal_d_separator exists, `None` is returned</span>

<span class="sd">&gt;&gt;&gt; other_z = nx.find_minimal_d_separator(G, x | y, {&quot;H2&quot;, &quot;H3&quot;})</span>
<span class="sd">&gt;&gt;&gt; other_z is None</span>
<span class="sd">True</span>


<span class="sd">References</span>
<span class="sd">----------</span>

<span class="sd">.. [1] Pearl, J.  (2009).  Causality.  Cambridge: Cambridge University Press.</span>

<span class="sd">.. [2] Darwiche, A.  (2009).  Modeling and reasoning with Bayesian networks.</span>
<span class="sd">   Cambridge: Cambridge University Press.</span>

<span class="sd">.. [3] Shachter, Ross D. &quot;Bayes-ball: The rational pastime (for</span>
<span class="sd">   determining irrelevance and requisite information in belief networks</span>
<span class="sd">   and influence diagrams).&quot; In Proceedings of the Fourteenth Conference</span>
<span class="sd">   on Uncertainty in Artificial Intelligence (UAI), (pp. 480–487). 1998.</span>

<span class="sd">.. [4] Koller, D., &amp; Friedman, N. (2009).</span>
<span class="sd">   Probabilistic graphical models: principles and techniques. The MIT Press.</span>

<span class="sd">.. [5] https://en.wikipedia.org/wiki/Causal_Markov_condition</span>

<span class="sd">.. [6] https://en.wikipedia.org/wiki/Berkson%27s_paradox</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">chain</span>

<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">networkx.utils</span> <span class="kn">import</span> <span class="n">UnionFind</span><span class="p">,</span> <span class="n">not_implemented_for</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;is_d_separator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;is_minimal_d_separator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;find_minimal_d_separator&quot;</span><span class="p">,</span>
    <span class="s2">&quot;d_separated&quot;</span><span class="p">,</span>
    <span class="s2">&quot;minimal_d_separator&quot;</span><span class="p">,</span>
<span class="p">]</span>


<div class="viewcode-block" id="is_d_separator">
<a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.d_separation.is_d_separator.html#networkx.algorithms.d_separation.is_d_separator">[docs]</a>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s2">&quot;undirected&quot;</span><span class="p">)</span>
<span class="nd">@nx</span><span class="o">.</span><span class="n">_dispatchable</span>
<span class="k">def</span> <span class="nf">is_d_separator</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return whether node sets `x` and `y` are d-separated by `z`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : nx.DiGraph</span>
<span class="sd">        A NetworkX DAG.</span>

<span class="sd">    x : node or set of nodes</span>
<span class="sd">        First node or set of nodes in `G`.</span>

<span class="sd">    y : node or set of nodes</span>
<span class="sd">        Second node or set of nodes in `G`.</span>

<span class="sd">    z : node or set of nodes</span>
<span class="sd">        Potential separator (set of conditioning nodes in `G`). Can be empty set.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : bool</span>
<span class="sd">        A boolean that is true if `x` is d-separated from `y` given `z` in `G`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        The *d-separation* test is commonly used on disjoint sets of</span>
<span class="sd">        nodes in acyclic directed graphs.  Accordingly, the algorithm</span>
<span class="sd">        raises a :exc:`NetworkXError` if the node sets are not</span>
<span class="sd">        disjoint or if the input graph is not a DAG.</span>

<span class="sd">    NodeNotFound</span>
<span class="sd">        If any of the input nodes are not found in the graph,</span>
<span class="sd">        a :exc:`NodeNotFound` exception is raised</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A d-separating set in a DAG is a set of nodes that</span>
<span class="sd">    blocks all paths between the two sets. Nodes in `z`</span>
<span class="sd">    block a path if they are part of the path and are not a collider,</span>
<span class="sd">    or a descendant of a collider. Also colliders that are not in `z`</span>
<span class="sd">    block a path. A collider structure along a path</span>
<span class="sd">    is ``... -&gt; c &lt;- ...`` where ``c`` is the collider node.</span>

<span class="sd">    https://en.wikipedia.org/wiki/Bayesian_network#d-separation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">y</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">{</span><span class="n">z</span><span class="p">}</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">z</span>

        <span class="n">intersection</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">z</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">z</span>
        <span class="k">if</span> <span class="n">intersection</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The sets are not disjoint, with intersection </span><span class="si">{</span><span class="n">intersection</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">set_v</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">z</span>
        <span class="k">if</span> <span class="n">set_v</span> <span class="o">-</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node(s) </span><span class="si">{</span><span class="n">set_v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="si">}</span><span class="s2"> are not found in G&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">(</span><span class="s2">&quot;One of x, y, or z is not a node or a set of nodes in G&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_directed_acyclic_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;graph should be directed acyclic&quot;</span><span class="p">)</span>

    <span class="c1"># contains -&gt; and &lt;-&gt; edges from starting node T</span>
    <span class="n">forward_deque</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span>
    <span class="n">forward_visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c1"># contains &lt;- and - edges from starting node T</span>
    <span class="n">backward_deque</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">backward_visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">ancestors_or_z</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">x</span><span class="p">])</span> <span class="o">|</span> <span class="n">z</span> <span class="o">|</span> <span class="n">x</span>

    <span class="k">while</span> <span class="n">forward_deque</span> <span class="ow">or</span> <span class="n">backward_deque</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">backward_deque</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">backward_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">backward_visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># add &lt;- edges to backward deque</span>
            <span class="n">backward_deque</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">backward_visited</span><span class="p">)</span>
            <span class="c1"># add -&gt; edges to forward deque</span>
            <span class="n">forward_deque</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">succ</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">forward_visited</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">forward_deque</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">forward_deque</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">forward_visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">y</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># Consider if -&gt; node &lt;- is opened due to ancestor of node in z</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">ancestors_or_z</span><span class="p">:</span>
                <span class="c1"># add &lt;- edges to backward deque</span>
                <span class="n">backward_deque</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">backward_visited</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
                <span class="c1"># add -&gt; edges to forward deque</span>
                <span class="n">forward_deque</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">succ</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">-</span> <span class="n">forward_visited</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="find_minimal_d_separator">
<a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.d_separation.find_minimal_d_separator.html#networkx.algorithms.d_separation.find_minimal_d_separator">[docs]</a>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s2">&quot;undirected&quot;</span><span class="p">)</span>
<span class="nd">@nx</span><span class="o">.</span><span class="n">_dispatchable</span>
<span class="k">def</span> <span class="nf">find_minimal_d_separator</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">included</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">restricted</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a minimal d-separating set between `x` and `y` if possible</span>

<span class="sd">    A d-separating set in a DAG is a set of nodes that blocks all</span>
<span class="sd">    paths between the two sets of nodes, `x` and `y`. This function</span>
<span class="sd">    constructs a d-separating set that is &quot;minimal&quot;, meaning no nodes can</span>
<span class="sd">    be removed without it losing the d-separating property for `x` and `y`.</span>
<span class="sd">    If no d-separating sets exist for `x` and `y`, this returns `None`.</span>

<span class="sd">    In a DAG there may be more than one minimal d-separator between two</span>
<span class="sd">    sets of nodes. Minimal d-separators are not always unique. This function</span>
<span class="sd">    returns one minimal d-separator, or `None` if no d-separator exists.</span>

<span class="sd">    Uses the algorithm presented in [1]_. The complexity of the algorithm</span>
<span class="sd">    is :math:`O(m)`, where :math:`m` stands for the number of edges in</span>
<span class="sd">    the subgraph of G consisting of only the ancestors of `x` and `y`.</span>
<span class="sd">    For full details, see [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : graph</span>
<span class="sd">        A networkx DAG.</span>
<span class="sd">    x : set | node</span>
<span class="sd">        A node or set of nodes in the graph.</span>
<span class="sd">    y : set | node</span>
<span class="sd">        A node or set of nodes in the graph.</span>
<span class="sd">    included : set | node | None</span>
<span class="sd">        A node or set of nodes which must be included in the found separating set,</span>
<span class="sd">        default is None, which means the empty set.</span>
<span class="sd">    restricted : set | node | None</span>
<span class="sd">        Restricted node or set of nodes to consider. Only these nodes can be in</span>
<span class="sd">        the found separating set, default is None meaning all nodes in ``G``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    z : set | None</span>
<span class="sd">        The minimal d-separating set, if at least one d-separating set exists,</span>
<span class="sd">        otherwise None.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        Raises a :exc:`NetworkXError` if the input graph is not a DAG</span>
<span class="sd">        or if node sets `x`, `y`, and `included` are not disjoint.</span>

<span class="sd">    NodeNotFound</span>
<span class="sd">        If any of the input nodes are not found in the graph,</span>
<span class="sd">        a :exc:`NodeNotFound` exception is raised.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] van der Zander, Benito, and Maciej Liśkiewicz. &quot;Finding</span>
<span class="sd">        minimal d-separators in linear time and applications.&quot; In</span>
<span class="sd">        Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_directed_acyclic_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;graph should be directed acyclic&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">y</span>

        <span class="k">if</span> <span class="n">included</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">included</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">included</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="n">included</span> <span class="o">=</span> <span class="p">{</span><span class="n">included</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">restricted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">restricted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">restricted</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="n">restricted</span> <span class="o">=</span> <span class="p">{</span><span class="n">restricted</span><span class="p">}</span>

        <span class="n">set_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">included</span> <span class="o">|</span> <span class="n">restricted</span>
        <span class="k">if</span> <span class="n">set_y</span> <span class="o">-</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node(s) </span><span class="si">{</span><span class="n">set_y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="si">}</span><span class="s2"> are not found in G&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">(</span>
            <span class="s2">&quot;One of x, y, included or restricted is not a node or set of nodes in G&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">included</span> <span class="o">&lt;=</span> <span class="n">restricted</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Included nodes </span><span class="si">{</span><span class="n">included</span><span class="si">}</span><span class="s2"> must be in restricted nodes </span><span class="si">{</span><span class="n">restricted</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">intersection</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">included</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">included</span>
    <span class="k">if</span> <span class="n">intersection</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The sets x, y, included are not disjoint. Overlap: </span><span class="si">{</span><span class="n">intersection</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">nodeset</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">included</span>
    <span class="n">ancestors_x_y_included</span> <span class="o">=</span> <span class="n">nodeset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodeset</span><span class="p">])</span>

    <span class="n">z_init</span> <span class="o">=</span> <span class="n">restricted</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ancestors_x_y_included</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">))</span>

    <span class="n">x_closure</span> <span class="o">=</span> <span class="n">_reachable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ancestors_x_y_included</span><span class="p">,</span> <span class="n">z_init</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x_closure</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">z_updated</span> <span class="o">=</span> <span class="n">z_init</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x_closure</span> <span class="o">|</span> <span class="n">included</span><span class="p">)</span>
    <span class="n">y_closure</span> <span class="o">=</span> <span class="n">_reachable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ancestors_x_y_included</span><span class="p">,</span> <span class="n">z_updated</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z_updated</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">y_closure</span> <span class="o">|</span> <span class="n">included</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_minimal_d_separator">
<a class="viewcode-back" href="../../../reference/algorithms/generated/networkx.algorithms.d_separation.is_minimal_d_separator.html#networkx.algorithms.d_separation.is_minimal_d_separator">[docs]</a>
<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s2">&quot;undirected&quot;</span><span class="p">)</span>
<span class="nd">@nx</span><span class="o">.</span><span class="n">_dispatchable</span>
<span class="k">def</span> <span class="nf">is_minimal_d_separator</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">included</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">restricted</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if `z` is a minimal d-separator for `x` and `y`.</span>

<span class="sd">    A d-separator, `z`, in a DAG is a set of nodes that blocks</span>
<span class="sd">    all paths from nodes in set `x` to nodes in set `y`.</span>
<span class="sd">    A minimal d-separator is a d-separator `z` such that removing</span>
<span class="sd">    any subset of nodes makes it no longer a d-separator.</span>

<span class="sd">    Note: This function checks whether `z` is a d-separator AND is</span>
<span class="sd">    minimal. One can use the function `is_d_separator` to only check if</span>
<span class="sd">    `z` is a d-separator. See examples below.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : nx.DiGraph</span>
<span class="sd">        A NetworkX DAG.</span>
<span class="sd">    x : node | set</span>
<span class="sd">        A node or set of nodes in the graph.</span>
<span class="sd">    y : node | set</span>
<span class="sd">        A node or set of nodes in the graph.</span>
<span class="sd">    z : node | set</span>
<span class="sd">        The node or set of nodes to check if it is a minimal d-separating set.</span>
<span class="sd">        The function :func:`is_d_separator` is called inside this function</span>
<span class="sd">        to verify that `z` is in fact a d-separator.</span>
<span class="sd">    included : set | node | None</span>
<span class="sd">        A node or set of nodes which must be included in the found separating set,</span>
<span class="sd">        default is ``None``, which means the empty set.</span>
<span class="sd">    restricted : set | node | None</span>
<span class="sd">        Restricted node or set of nodes to consider. Only these nodes can be in</span>
<span class="sd">        the found separating set, default is ``None`` meaning all nodes in ``G``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    bool</span>
<span class="sd">        Whether or not the set `z` is a minimal d-separator subject to</span>
<span class="sd">        `restricted` nodes and `included` node constraints.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; G = nx.path_graph([0, 1, 2, 3], create_using=nx.DiGraph)</span>
<span class="sd">    &gt;&gt;&gt; G.add_node(4)</span>
<span class="sd">    &gt;&gt;&gt; nx.is_minimal_d_separator(G, 0, 2, {1})</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; # since {1} is the minimal d-separator, {1, 3, 4} is not minimal</span>
<span class="sd">    &gt;&gt;&gt; nx.is_minimal_d_separator(G, 0, 2, {1, 3, 4})</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; # alternatively, if we only want to check that {1, 3, 4} is a d-separator</span>
<span class="sd">    &gt;&gt;&gt; nx.is_d_separator(G, 0, 2, {1, 3, 4})</span>
<span class="sd">    True</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NetworkXError</span>
<span class="sd">        Raises a :exc:`NetworkXError` if the input graph is not a DAG.</span>

<span class="sd">    NodeNotFound</span>
<span class="sd">        If any of the input nodes are not found in the graph,</span>
<span class="sd">        a :exc:`NodeNotFound` exception is raised.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] van der Zander, Benito, and Maciej Liśkiewicz. &quot;Finding</span>
<span class="sd">        minimal d-separators in linear time and applications.&quot; In</span>
<span class="sd">        Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function works on verifying that a set is minimal and</span>
<span class="sd">    d-separating between two nodes. Uses criterion (a), (b), (c) on</span>
<span class="sd">    page 4 of [1]_. a) closure(`x`) and `y` are disjoint. b) `z` contains</span>
<span class="sd">    all nodes from `included` and is contained in the `restricted`</span>
<span class="sd">    nodes and in the union of ancestors of `x`, `y`, and `included`.</span>
<span class="sd">    c) the nodes in `z` not in `included` are contained in both</span>
<span class="sd">    closure(x) and closure(y). The closure of a set is the set of nodes</span>
<span class="sd">    connected to the set by a directed path in G.</span>

<span class="sd">    The complexity is :math:`O(m)`, where :math:`m` stands for the</span>
<span class="sd">    number of edges in the subgraph of G consisting of only the</span>
<span class="sd">    ancestors of `x` and `y`.</span>

<span class="sd">    For full details, see [1]_.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_directed_acyclic_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span><span class="s2">&quot;graph should be directed acyclic&quot;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">{</span><span class="n">y</span><span class="p">}</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">y</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">{</span><span class="n">z</span><span class="p">}</span> <span class="k">if</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">G</span> <span class="k">else</span> <span class="n">z</span>

        <span class="k">if</span> <span class="n">included</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">included</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">included</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="n">included</span> <span class="o">=</span> <span class="p">{</span><span class="n">included</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">restricted</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">restricted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">restricted</span> <span class="ow">in</span> <span class="n">G</span><span class="p">:</span>
            <span class="n">restricted</span> <span class="o">=</span> <span class="p">{</span><span class="n">restricted</span><span class="p">}</span>

        <span class="n">set_y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">included</span> <span class="o">|</span> <span class="n">restricted</span>
        <span class="k">if</span> <span class="n">set_y</span> <span class="o">-</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The node(s) </span><span class="si">{</span><span class="n">set_y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="si">}</span><span class="s2"> are not found in G&quot;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NodeNotFound</span><span class="p">(</span>
            <span class="s2">&quot;One of x, y, z, included or restricted is not a node or set of nodes in G&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">included</span> <span class="o">&lt;=</span> <span class="n">z</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Included nodes </span><span class="si">{</span><span class="n">included</span><span class="si">}</span><span class="s2"> must be in proposed separating set z </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">restricted</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Separating set </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2"> must be contained in restricted set </span><span class="si">{</span><span class="n">restricted</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">intersection</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="ow">or</span> <span class="n">y</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">intersection</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">nx</span><span class="o">.</span><span class="n">NetworkXError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The sets are not disjoint, with intersection </span><span class="si">{</span><span class="n">intersection</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">nodeset</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">included</span>
    <span class="n">ancestors_x_y_included</span> <span class="o">=</span> <span class="n">nodeset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodeset</span><span class="p">])</span>

    <span class="c1"># criterion (a) -- check that z is actually a separator</span>
    <span class="n">x_closure</span> <span class="o">=</span> <span class="n">_reachable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ancestors_x_y_included</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x_closure</span> <span class="o">&amp;</span> <span class="n">y</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># criterion (b) -- basic constraint; included and restricted already checked above</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="n">ancestors_x_y_included</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># criterion (c) -- check that z is minimal</span>
    <span class="n">y_closure</span> <span class="o">=</span> <span class="n">_reachable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ancestors_x_y_included</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="n">z</span> <span class="o">-</span> <span class="n">included</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">x_closure</span> <span class="o">&amp;</span> <span class="n">y_closure</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<span class="nd">@not_implemented_for</span><span class="p">(</span><span class="s2">&quot;undirected&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_reachable</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Modified Bayes-Ball algorithm for finding d-connected nodes.</span>

<span class="sd">    Find all nodes in `a` that are d-connected to those in `x` by</span>
<span class="sd">    those in `z`. This is an implementation of the function</span>
<span class="sd">    `REACHABLE` in [1]_ (which is itself a modification of the</span>
<span class="sd">    Bayes-Ball algorithm [2]_) when restricted to DAGs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    G : nx.DiGraph</span>
<span class="sd">        A NetworkX DAG.</span>
<span class="sd">    x : node | set</span>
<span class="sd">        A node in the DAG, or a set of nodes.</span>
<span class="sd">    a : node | set</span>
<span class="sd">        A (set of) node(s) in the DAG containing the ancestors of `x`.</span>
<span class="sd">    z : node | set</span>
<span class="sd">        The node or set of nodes conditioned on when checking d-connectedness.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : set</span>
<span class="sd">        The closure of `x` in `a` with respect to d-connectedness</span>
<span class="sd">        given `z`.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] van der Zander, Benito, and Maciej Liśkiewicz. &quot;Finding</span>
<span class="sd">        minimal d-separators in linear time and applications.&quot; In</span>
<span class="sd">        Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.</span>

<span class="sd">    .. [2] Shachter, Ross D. &quot;Bayes-ball: The rational pastime</span>
<span class="sd">       (for determining irrelevance and requisite information in</span>
<span class="sd">       belief networks and influence diagrams).&quot; In Proceedings of the</span>
<span class="sd">       Fourteenth Conference on Uncertainty in Artificial Intelligence</span>
<span class="sd">       (UAI), (pp. 480–487). 1998.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_pass</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether a ball entering node `v` along edge `e` passes to `n` along `f`.</span>

<span class="sd">        Boolean function defined on page 6 of [1]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        e : bool</span>
<span class="sd">            Directed edge by which the ball got to node `v`; `True` iff directed into `v`.</span>
<span class="sd">        v : node</span>
<span class="sd">            Node where the ball is.</span>
<span class="sd">        f : bool</span>
<span class="sd">            Directed edge connecting nodes `v` and `n`; `True` iff directed `n`.</span>
<span class="sd">        n : node</span>
<span class="sd">            Checking whether the ball passes to this node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        b : bool</span>
<span class="sd">            Whether the ball passes or not.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] van der Zander, Benito, and Maciej Liśkiewicz. &quot;Finding</span>
<span class="sd">           minimal d-separators in linear time and applications.&quot; In</span>
<span class="sd">           Uncertainty in Artificial Intelligence, pp. 637-647. PMLR, 2020.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_element_of_A</span> <span class="o">=</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">a</span>
        <span class="c1"># almost_definite_status = True  # always true for DAGs; not so for RCGs</span>
        <span class="n">collider_if_in_Z</span> <span class="o">=</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">z</span> <span class="ow">or</span> <span class="p">(</span><span class="n">e</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">is_element_of_A</span> <span class="ow">and</span> <span class="n">collider_if_in_Z</span>  <span class="c1"># and almost_definite_status</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">succ</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="n">node</span><span class="p">))</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">while</span> <span class="nb">any</span><span class="p">(</span><span class="n">queue</span><span class="p">):</span>
        <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="p">((</span><span class="kc">False</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">pred</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">succs</span> <span class="o">=</span> <span class="p">((</span><span class="kc">True</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">succ</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
        <span class="n">f_n_pairs</span> <span class="o">=</span> <span class="n">chain</span><span class="p">(</span><span class="n">preds</span><span class="p">,</span> <span class="n">succs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">f_n_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">processed</span> <span class="ow">and</span> <span class="n">_pass</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
                <span class="n">processed</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">{</span><span class="n">w</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="ow">in</span> <span class="n">processed</span><span class="p">}</span>


<span class="c1"># Deprecated functions:</span>
<span class="k">def</span> <span class="nf">d_separated</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return whether nodes sets ``x`` and ``y`` are d-separated by ``z``.</span>

<span class="sd">    .. deprecated:: 3.3</span>

<span class="sd">        This function is deprecated and will be removed in NetworkX v3.5.</span>
<span class="sd">        Please use `is_d_separator(G, x, y, z)`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;d_separated is deprecated and will be removed in NetworkX v3.5.&quot;</span>
        <span class="s2">&quot;Please use `is_d_separator(G, x, y, z)`.&quot;</span><span class="p">,</span>
        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_d_separator</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">minimal_d_separator</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a minimal_d-separating set between `x` and `y` if possible</span>

<span class="sd">    .. deprecated:: 3.3</span>

<span class="sd">        minimal_d_separator is deprecated and will be removed in NetworkX v3.5.</span>
<span class="sd">        Please use `find_minimal_d_separator(G, x, y)`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="s2">&quot;This function is deprecated and will be removed in NetworkX v3.5.&quot;</span>
            <span class="s2">&quot;Please use `is_d_separator(G, x, y)`.&quot;</span>
        <span class="p">),</span>
        <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">nx</span><span class="o">.</span><span class="n">find_minimal_d_separator</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

                </article>
              
              
              
              
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2004-2024, NetworkX Developers.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.4.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>